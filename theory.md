## Лекция 1

**Метод func при таком написании const не может менять объект, для которого вызыван**
```
class Name
{
  double func() const;    
}
```
**Два двоеточия определяют область видимости. func в области видимости класса Name**
```
double Name::func() const
{
  ...
}
```
**Вызов**
```
Name t;
double result = t.func();
```

Берем указатель на себя первым аргументом -> можем говорить "сделай для себя". Иногда необходимо писать явный this.
В плюсах мы часто не видим того, чего нет в коде. То есть, придется смотреть "через волшебные очки".
Метод внутри типа и отдельная функция - разные вещи.

##### Обобщение типов. Обобщение функций. (template<typename T>)
C++ сортировка быстрее за счет шаблона, но компилируется дольше за счет подставления разных типов.
Стандартная библиотека содержит стандартные обобщенные контейнеры и обобобщенные алгоритмы над ними.
Она серьезно упрощает работу над кэшами. unordered_map - хэштаблица внутри, удобно вполне.

***Есть контест - ProblemLC. Код должен его проходить.***

**Для класса нужен конструктор.**
```
template <typename T, typename KeyT = int>
struct cache_t
{
  size_t sz_;
  ...
  cache_t(size)t sz) : sz_(sz) {} // CREATOR
}

cache_t<page_t> c{m}; //creating with creator
```

### Объекты обладают собственным поведение. Необходимо ОЧЕНЬ хорошее понимание.

**ДЗ№1. Приходит количество ключей, ключи и размер кэша. Выбрать один из алгоритмов и реализовать. Плюс написать тесты. Тестить через реализацию Белади и что-нить ещё.**

##### Отправлять на konstantin.vladimirov@gmail.com

## Лекция 2

#### Указатели и функции

Для типа необходимы диапазон значений и операции. В С# и Java. В С\С++ надо задать ещё пространственные соотношения - адрес. Адресам соотвествует тип: i4*, если изначальный тип i4.  
NULL - void*  
0 - int  
nullptr - nullptr_t **наш выбор**  
p[2] == *(p+2)  // ((p+2*sizeof(p))  

**Ссылки (lvalue refernces) - другое имя для объекта**
```
int x;
int &y = x; //у - ещё одно имя для х
```
#### Важно не путать с разыменованием.
```
int x, y;
int &xref = x; //теперь нельзя связать xref с у
xref = y; // x=y
int *xptr = &xref; //*xptr = &x
int &*xrefptr = &xref; //ERROR. Нельзя указатель на ссылку сделать
int *&xptrref = xptr; //ссылка на указатель.
```
**Константность для ссылок**
```
const char *s1; //s1 указатель на константный чар
char const *s2; //то же самое
```
#### Const означает константность слева от него, за исключением если слева ничего нет.
```
char * const s3; //константый указатель на char. Компилятор выдаст ошибку. Не сможем потом ни с чем его связать.
char const * const s4; //тоже ошибка

const &r1 = r; //неконстантная ссылка (она ведет себя как константный указатель)
const char &r2 = r1;
```
**Ссылку можно передать как аргумент в функцию. Но не всегда понятно, что передали.**

#### Разобраться в unit-test. Cвою систему писать не надо, есть Catch, BoostTest, GoogleTest. Этим можно тестить свой код.
*В записи лекции описан интересный графический алгоритм.*

**Инварианты. Инкапсуляция.**
Внешние функции, работающими с объектами этого типа, которые могут являться проблемой для инвариантов.  
В языке С есть инкапсуляция - только методы этого типа(класса) могут с ним работать.  
Для этого мы можем сделать тип непрозрачным(opaque). Пользователь сможеть работать только с указателями на объект только методами этого типа.  
Но этот подход далеко не лучший. Однако в С++ его улучшили - private.  
Отличие структур и классов - у структуры по умолчанию всё public, у класса - private. Аналогично с наследованием. + идеология.  
**Рекомендация - делать все объекты приватными и писать для них геттеры и сеттеры**
```
class AlmostOpen
{
  int x;
public:
  int get_x() xonst {return x;}
  void set_x(int xval) {x = xval;}
}
```

#### У нас линейная модель памяти, и приведя указатель к char* мы можем нарушить все инварианты. Но мы этого НЕ ХОТИМ. Иначе приведем объект в неконсистентное состояние(дальнейшие операции над объектом непредсказуемы).

Инвариант const int refernce. Инкапсуляция - свойство типа, а не его объектов.  
Инкапсуляция делает критически важными контсрукторы.  
Чтобы объекты создавались в консистентном состоянии, надо использовать new и delete. Они так же будут вызывать контсруктор и деструктор.
```
int *t = new Widget;
delete t;

int *p = new Widget[5];
delete [] p;
```

**ДЗ№2. Получаем количетсво наборов точек, за ним наборы точек. Надо вынести номера треугольников пересекающихся с другими треугольниками. Использовать книжку Geometric Tools for Computer Graphics - Eberly, Shchneider**

## Лекция 3

**Область видимости и время жизни**  
```
if (b > 5)
{
  int c = b+5;
} //c scope end, c lifetime end
```
*scope > lifetime при delete  
lifetime > scope при static int x*  
Указатель, ссылающийся на переменную с истекшим временем жизни называется провисшим(dangling)
```
int *pc;
if (b > 5)
{
  int c = b + 5;
  pc = &c;
} //c scope end, c lifetime end, pc dangles
b += *pc; //runtime fail в лучшем случае
```
#### Аналогично провисшая ссылка
**Константные(и только они) lvalue ссылки продлевают жизнь временных объектов**
```
const int &lx = 0;
int x = ls;
int foo();
const int &ly = 42 + foo();
int y = ly;
```
#### Ссылка связыввается со значением, а не со ссылкой, поэтому константная ссылка может провиснуть при возврате из функций.

```
struct S
{ int x; const int &y; };
S x{1,2};
S *p = new S{1,2}; //fail, refernce dangle
```
На первой строчке постоянный объект, а на второй висячая ссылка, потому что временный объект, продлявший жизнь константе закончился в конце выражения. Поэтому ссылка как член клссса - странно и не оч.  
Неконстантные левые ссылки не создают временных объектов и отказываются связываться с литералами.
```
int &x = 1; //compilation error
```
### Decaying
```
int foo(const int& t)
{
  return t;
}

int arr[5];
int *t = arr + 3; //OK
arr = t; //FAIL
```
Массив деградирует к указателю на свой первый элемент, когда он использован как rvalue. В языке С lvalue и rvalue можно отделить синтаксически, в С++ всё не так просто.  
В С++ lvalue - location value - всё, у чего есть расположение в памяти. Технически может существовать lvalue ссылка на массив, хоть массив не может стоять слева в присваивании.
```
int *x[20]; //массив указателей
int (*y)[20]; //указатель на массив
int (&z)[20] = *y; //ссылка на массив
```
Cdecl - https://docs.microsoft.com/ru-ru/cpp/cpp/cdecl?view=vs-2019  
**Борьбa против cdecl: typedef**
void (*bar(int x, void (*func)(int&))) (int&); - bar - указатель на функцию, которая берет ссылку и возвращает указатель на функцию. которая вoзвращает void и берет ссылку.
#### typedef
```
typedef void (*ptr_to_fref) (int&);
ptr_to_fref bar(int x, ptr_to_fref func);
```
Но typedef не работает с шаблонами.  
**Альтернатива - using**
```
using ptr_to_fref = void(*)(int&);
ptr_to_fref bar(int x, ptr_to_fref func);
```
А с шаблоном:
```
template<typename T>
using ptr_to_fref = void (*) (T&);
```

### Конкретные классы
**Имена и сущности**  
Перегузка функций помогает решать некоторые парадоксы языка С в их реализации в С++. Перегрузка в С невозможна, так как этот язык даёт гарантию по именам. Процесс искажения имён называется манглированием. Поэтому в С нельзя внести метод в структуру, так как нет манглирования типом. Структура с методом есть часть типа.  
*Если написать extern "C" double sqrt(double), то будет как в С*  
**Манглирование не специфицировано. Разные компиляторы имеют разные правила манглирования. Поэтому мир функционирует на С API на границах интерфейсов.**  
Мы не можем делать так:
```
extern "C" template <typename T> void foo(T x);
struct S { extern "C" void foo(); }
```
Не можем, потому что в первом случае обобещение данных, а во втором объединение данных с методами. А это невозможно без манглирования имён.
### Получается, мы может объединять данные и обобщать их с методами исключительно благодаря манглированию
**Если убрать из С гарантию по именам, то постепенно можно получить С++. Поэтому С жив и имеет на это право.**    
Наличие перегрузок вносит некоторые сложности.
```
float sqrt(float x);
double sqrt(double x);
sqrt(42); //не знаем, что вызвать
```
Имеет место разрешение имён. В момент, когда мы к чему-то обращаемся, компилятор должен разрешить имя. Бывает в шаблонных контекстах это очень сложно. В случае выше мы получим ошибку компиляции.  
Есть базовые случаи разрешения перегрузки(точное совпадение, сандартные преобразования, переменно число аргументов, неправильно связанные ссылки).  
**Методы класса можно перегружать, особенно это полезно для конструкторов**
```
class line_t
{
  float a_ = -1.0f, b_ = 1.0f, c_ = 0.0f;
public:
  linet_t() {}; //по умолчанию
  line_t(const point_t &p1, const point_t &p2); //из двух точек
  line_t(float a, float b, float c); //явные параметры линии
}
```
Как только вызовем конструктор с точным совпадением, он выиграет.  
### Имена искажаются не только входными и выходными типами, но ещё тем, чему принадлежит метод. Появляется концепция пространства имён.
В С все имена принадлежат глобальному пространству имёню.
**В С++ вся стандартная библиотека принадлежит к std. Исключения - старые хедера, наследованные из С, к примеру, <stdlib.h>. Чтобы завернуть в std, имеем новые хедера - cstdlib. **  
*Мы не сможем написать свои имена в пространство стандартных имён.*  
### Мы можем создать свои пространства имён.
```
namespace Containers
{
  struct List {
    struct Node {
      ....
    };
  };
}
```
**Пространства имён могут быть переоткрыты.**   
Структура вводит тип данных, тип не должен существовать, если нет его объектов. А у неймспейса не обязательно должны быть экземпляры. Плюс вторйо смысл директивы using - для того, чтобы вводить имена из одного пространства имён в другое.  
```
using namespace X; //использовать аккуратно, в других неймспейсах может возникнуть конфликт имён
```
#### Анонимные пространства имён
Замена статическим функциям(внутри модуля, то есть тем, которые не видны снаружи).
```
namespace
{
  int foo() {return 42;}
}
int bar() {return foo(); }
```
Наденем волшебные очки и получим рандомное имя и после объявления using namespace рандомное имя.  
### Правила хорошего тона:
1) Не засорять глобальное пространство имён  
2) Никогда не писать using namespace в заголовочных файлах  
3) Использовать анонимные пространства имён вместо статистических функций  
4) Никогда не использовать анонимные пространства имён в заголовочных файлах  
```
#include <iostream>

namespace {
  const char * const helloworld = "Hello, world";
} //явно помечено, что не экспорт

int main()
{
  std::cout << helloworld << std::endl;
}
```

## Лекция 4

**explicit конструкторы блокируют неявные преобразования типов.**
При перегрузках в некоторых случаях надо заглядывать в стандарт языка. Компилятор находит viable кандидатов, а из них выбирает подходящий. И, в стандарте указано, что должна быть последовательность неявных преобразований.  

### Конструкторы
Используется для инициализации.
**Приямая инициализация**
```
struct foo
{
  foo(int x) {}
};
foo f{2};
foo f = 2; //инициализация копированием
```
Конструктор с одним аргументом определяет неявное преобразование типа, конструктор с двумя аргментами определяет неявное преобразование из списка инициализации двух аргументов.  
**При прямой инциализации рассматриваются все конструкторы**  
Если написать explicit foo(int x) {}, то не сможем инициализировать копированием. Поэтому стоит избегать explicit консрукторы без понимания.  
#### Всё, что похоже на функцию, считается функцией в С++

### Cписки инициализации
Полезны при наличии аргументов.
```
template <typename T> struct Point2D
{
  T x_, y_;
  Point2D(T x, T y): x_(x), y_(y) {}
}
```
Лучше, чем
```
Point2D(T x, T y) {x_ = x, y_ = y;}
```
Надевая волшебные очки, увидим во втором случае(компилятор сделает так):
```
Point2D(t x, T y) x_(defx), y_(defy) { x_ = x, y_ = y;}
```
**Тривиальная инициализация**
```
template <typename T> class list_t
{
  node_t *top_, *back_;
public:
  list_t(): top_(nullptr), back_(nullptr) {}
}
//или
template <typename T> class list_t
{
node *top_ = nullptr, *back_ = nullptr;
}
```
**Почему тривиальная инициализация незаменима? - Константные члены и ссылки**
```
class Weirdo
{
  int &x_;
  const int y_;
public:
  Weirdo(int &x) : x_(x), y_(42) {}
}
```
#### Лучше не использовать члены-ссылки и константы

#### Если конструкто делает нетривиальные вещи, его можно делигировать:
```
stuct class_c
{
  int max = 0, min = 0;
  class_c(int my_max) {max = my_max > 0 ? my_max : 10; }
  class_c(int my_max, int my_min) : clacc_c(my_max) {min = my_min > 0 && my_min < max ? my_min : 1;}
}
```
### Деструкторы
```
template <typename T> class MyVector //так себе MyVector
{
  int size_, capacity_;
  T* buf_;
public:
  MyVector(int cap = 0) : size_(0), capacity_(cap), buf_(new T[cap]) {} //лучше explicit

  ~MyVector() {delete [] buf_;}
}
```
**Бывает, пишут лишние обнуления:**
```
buf_ = nullptr;
size_ = 0;
capacity_ = 0;
```
**После отработки деструктора время жизни закончилось и поля принимают неопределённое состояние. Поэтому не нужны никакие обнуления.**  
### Value initialization
```
{ //local scope
  int a; //a undefined
  int b{}; //b val-initializated, hence zero
...
int *pvs = new int[5]{}; //calloc
```
**Для C++ нет альтернативы realloc**
Используем волшебные очки(с одним стеклом :D). Посмотрим на ПУСТОЙ класс.
```
class Empty
{
    Empty() {} //ctor
    ~Empty() {} //dtor
    Empty(const Empty&) {} //copy ctor
    Empty& operator = (const Empty&) {} //assignment
};
```
Все это и кое-что ещё генерирует компилятор.

### Инициализация по умолчанию (default)
```
int x; //contains garbage

struct foo{
  int x;
};
foo f; //x contains garbage coz of default initialization
```
Сделаем так, чтобы не генерировался консруктор по умолчанию.
```
struct Bar
{
    int x;
    Bar() : x(42) {}
}
Bar f; //x contains 42

struct Buz {Bar f;}
Buz b; //f.x contains 42
```
### Cемантика копирования
```
template <typename T> struct Point2D
{
    T x_, y_;
    Point2D() : x_(defx), y_(defy) {} //ctor
    ~Point2D() {} //dtor
    Point2D(const Point2D& rhx) : x_(rhs.x_), y(rhs.y_) {} //copy ctor
    Point2D& operator = (const Point2D& rhx) {x_ = rhs.x_; y_=rhx.y_; return *this;} //assignment
};
```
**По умолчанию конструктор копирования и присваивания реализут побитовое копирование и присваивание.**  
#### Компилятор может игнорировать побочные эффекты и пропускать копирование и присванивание, так как знает внутреннюю семантику - return value compilation

**Главная форма консруктора копировария**
```
struct Copyable
{
  Copyable(const Copyable &c);
}
```
Но вообще он может принимать и не константную ссылку, и даже как угодно cv-квалифицированную ссылку или значение.  

### cv-квалификация
```
const int c = 34; //can't change
volatile int v; //may unpredictable change at any moment
const volatile int cv = 42; //we can't change it, but it can be changed somehow -> cv-квалификация

int S::foo() const {return 42;} //we get const "this" here
int S::bar() volatile {return 42;} //we get volatile this
int S::buz() const volatile {return 42;} //similar

volatile std::vector v; //we can create it but can't do anything
```
Не можем ничего сделать, так как можем применить методы, квалифированные только как volitile или const volatile.  
**Недопустимая форма - шаблонный конструктор копирования. Комплиятор в таком случае сгенерирует консруктор по умолчанию.**  
```
template <typename T> struct Coercible
{
  template <typename U> Coercible(const Coercible<U> &c)
  {
    std::cout << "Hello!" << std::endl;
  }
};
Coercible<void> a;
Coercible<void> b{a}; //nothing on the screen (if U=T)

Coercible<int> c{a}; //Hello!
```
**Отличие копирования от присваивания:**  
В основном - способ инициализации. Присваивание - переписвание готоого объекта.  
В операторе присваивания иногда нужно проверять
```
if (this != &rhs) ...
```
Можем объявлять дефолтный конструктор, чтобы компилятор скомпилировал именно его
```
Point() = default;
```
Это имеет смысл, когда есть какой-то недефолтный конструктор, но нужен ещё дефолтный.  

### Владение ресурсом
Консруктор копирования и оператор присваивания предназначены для передачи владения ресурсом. Так как, к примеру, при передаче указателя, мы передаём управление памятью.
**Страшное goto**
```
if (cond)
{
  delete [] a;
  result = FAILURE;
  goto cleanup;
}
...//some code
cleanup:
  delete [] a;
  return result;
```
**Социальное-приемлемое goto**
```
do
{
  if(cond)
  {
    delete [] a;
    ...
  }
  ...
} while(0)
delete [] a;
return result;
```
***На самом деле оба можно юзать))***  
#### Чтобы не писать goto можно использовать технологию RAII: resourse asquisition is initialization
```
int foo(int n)
{
  Buffer a(n); //new called in creator
  ...
  if (cond) return FAILURE; //dtor called delete
  ...
  return SUCCESS; //dtor called delete
}
```
**Попытка спроектировать буффер как класс приведет double deletion
```
class Buffer
{
  int *p;
  public:
  //ctor
  //dtor
  Buffer(const Buffer& rhs) : p(rhs.p) {} //with magical glasses
  Buffer& operator= (const Buffer& rhs) { p = phs.p; } //with magical glasses
};
{Buffer x; Buffer y{x}; } //double deletion - two pointers on similar memory
```
Поэтому нужно написать
```
  Buffer(const Buffer& rhs) = delete;
  Buffer& operator= (const Buffer& rhs) = delete;
...
  {Buffer x; Buffer y{x}; } //compilation error
```
#### Поэтому и нет realloc, ведь копирование может быть запрещено (когда написали delete)
Инвариантом RAII класса является то, что никто, кроме методов класса не иметт владеющего доступа к p.  

Поисковость - это свойство дерева, когда любой элемент в правом поддереве больше элемента в левом. Удобно это тем, что любой ключ может быть найден начиная от верхушки дерева за время пропорциональное высоте дерева.  
Преобразовать поисковые деревья мы можем так: левый и правый поворот. Повороты меняют высоту поддерева.  
Надлежащим количеством поворота любое дерево можно сделать полезным, но эта задача нетривиальна. Проще при каждой вставке поворотами поддежривать какой-то инвариант, гарантирующий полезность дерева.    
Простеший инвариант: красно-чёрный.  
Это значит, что корень черный, все нулевые потомки черные, у каждого красного узла все потомки черные, на любом пути от данного узла до каждого из нижних листьев одинаковое количетсво черных узлов.  
Ещё инвариант: AVL.  

**ДЗ№3. К данным, хранщимся в дереве удобно применять range queries. На вход N количество ключей, потом сами ключи(целые числа). На вход М количетсво запросов, и далее все запросы. Нужно для каждого запроса подсчитать в дереве количетсво ключей, таких, что каждый из них лежит строго между его левой и правой границами включительно. Делать надо быстрее, чем через std::set.**

## Лекция 5
