## Лекция 1

**Метод func при таком написании const не может менять объект, для которого вызыван**
```
class Name
{
  double func() const;    
}
```
**Два двоеточия определяют область видимости. func в области видимости класса Name**
```
double Name::func() const
{
  ...
}
```
**Вызов**
```
Name t;
double result = t.func();
```

Берем указатель на себя первым аргументом -> можем говорить "сделай для себя". Иногда необходимо писать явный this.
В плюсах мы часто не видим того, чего нет в коде. То есть, придется смотреть "через волшебные очки".
Метод внутри типа и отдельная функция - разные вещи.

##### Обобщение типов. Обобщение функций. (template<typename T>)
C++ сортировка быстрее за счет шаблона, но компилируется дольше за счет подставления разных типов.
Стандартная библиотека содержит стандартные обобщенные контейнеры и обобобщенные алгоритмы над ними.
Она серьезно упрощает работу над кэшами. unordered_map - хэштаблица внутри, удобно вполне.

***Есть контест - ProblemLC. Код должен его проходить.***

**Для класса нужен конструктор.**
```
template <typename T, typename KeyT = int>
struct cache_t
{
  size_t sz_;
  ...
  cache_t(size)t sz) : sz_(sz) {} // CREATOR
}

cache_t<page_t> c{m}; //creating with creator
```

### Объекты обладают собственным поведение. Необходимо ОЧЕНЬ хорошее понимание.

**ДЗ№1. Приходит количество ключей, ключи и размер кэша. Выбрать один из алгоритмов и реализовать. Плюс написать тесты. Тестить через реализацию Белади и что-нить ещё.**

##### Отправлять на konstantin.vladimirov@gmail.com

## Лекция 2

#### Указатели и функции

Для типа необходимы диапазон значений и операции. В С# и Java. В С\С++ надо задать ещё пространственные соотношения - адрес. Адресам соотвествует тип: i4*, если изначальный тип i4.
NULL - void*
0 - int
nullptr - nullptr_t **наш выбор**
p[2] == *(p+2)  // ((p+2*sizeof(p))

**Ссылки (lvalue refernces) - другое имя для объекта**
```
int x;
int &y = x; //у - ещё одно имя для х
```
#### Важно не путать с разыменованием.
```
int x, y;
int &xref = x; //теперь нельзя связать xref с у
xref = y; // x=y
int *xptr = &xref; //*xptr = &x
int &*xrefptr = &xref; //ERROR. Нельзя указатель на ссылку сделать
int *&xptrref = xptr; //ссылка на указатель.
```
**Константность для ссылок**
```
const char *s1; //s1 указатель на константный чар
char const *s2; //то же самое
```
#### Const означает константность слева от него, за исключением если слева ничего нет.
```
char * const s3; //константый указатель на char. Компилятор выдаст ошибку. Не сможем потом ни с чем его связать.
char const * const s4; //тоже ошибка

const &r1 = r; //неконстантная ссылка (она ведет себя как константный указатель)
const char &r2 = r1;
```
**Ссылку можно передать как аргумент в функцию. Но не всегда понятно, что передали.**

#### Разобраться в unit-test. Cвою систему писать не надо, есть Catch, BoostTest, GoogleTest. Этим можно тестить свой код.
*В записи лекции описан интересный графический алгоритм.*

**Инварианты.**
Внешние функции, работающими с объектами этого типа, которые могут являться проблемой для инвариантов.
В языке С есть инкапсуляция - только методы этого типа(класса) могут с ним работать.
Для этого мы можем сделать тип непрозрачным(opaque). Пользователь сможеть работать только с указателями на объект только методами этого типа.
Но этот подход далеко не лучший. Однако в С++ его улучшили - private.
Отличие структур и классов - у структуры по умолчанию всё public, у класса - private. Аналогично с наследованием. + идеология.

#### У нас линейная модель памяти, и приведя указатель к char* мы можем нарушить все инварианты. Но мы этого НЕ ХОТИМ. Иначе приведем объект в неконсистентное состояние(дальнейшие операции над объектом непредсказуемы).

Инвариант const int refernce. Инкапсуляция - свойство типа, а не его объектов.
Инкапсуляция делает критически важными контсрукторы.
Чтобы объекты создавались в консистентном состоянии, надо использовать new и delete. Они так же будут вызывать контсруктор и деструктор.
```
int *t = new Widget;
delete t;

int *p = new Widget[5];
delete [] p;
```

**ДЗ№2. Получаем количетсво наборов точек, за ним наборы точек. Надо вынести номера треугольников пересекающихся с другими треугольниками. Использовать книжку Geometric Tools for Computer Graphics - Eberly, Shchneider**

## Лекция 3
